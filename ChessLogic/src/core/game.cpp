#include "game.h"
#include "utils/piece_factory.h"

#include <algorithm>
#include <iostream>

using namespace Chess;

Game::Game() 
    : m_currentPlayer(Color::White),
      m_whiteKingMoved(false),
      m_blackKingMoved(false)
{
    m_whiteRookMoved[0] = false;
    m_whiteRookMoved[1] = false;
    m_blackRookMoved[0] = false;
    m_blackRookMoved[1] = false;
    std::cout << "Game object created" << std::endl;
}

void Game::initializeGame() {
    m_board.initializeBoard();
    m_currentPlayer = Color::White;
    m_lastMoveInfo = LastMoveInfo();
    m_whiteKingMoved = false;
    m_blackKingMoved = false;
    m_whiteRookMoved[0] = false;
    m_whiteRookMoved[1] = false;
    m_blackRookMoved[0] = false;
    m_blackRookMoved[1] = false;
    std::cout << "Game initialized. White to move" << std::endl;
}

void Game::setCurrentTurn(Color color) {
    m_currentPlayer = color;
}

void Game::setCastlingRights(bool wk, bool wq, bool bk, bool bq) {
    this->wk = wk;
    this->wq = wq;
    this->bk = bk;
    this->bq = bq;
}

std::vector<Position> Game::getValidMoves(Position from) const {
    std::vector<Position> validMoves;

    const Piece* piece = m_board.getPieceAt(from);
    if (piece == nullptr || piece->getColor() != m_currentPlayer) {
        return validMoves;
    }

    std::vector<Position> pseudoLegalMoves = piece->getPossibleMoves(from, m_board);
    for (const Position& to : pseudoLegalMoves) {
        // !!! IMPORTANT PART: Check for check !!!
        // Create a temporary board or roll back changes after checking.
        // The easiest way: simulate a move and check isKingInCheck
        // (you need to temporarily change the board and then return it to its original state)
        // Or: implement willMovePutKingInCheck(from, to)

        // Example (simplified, without real simulation):
        // if (!willMovePutKingInCheck(from, to)) {
        //     validMoves.push_back(to);
        // }

        // For initial UI testing, until full check for check is implemented,
        // just add all pseudo-legal moves.
        // THIS IS TEMPORARY, WILL NEED TO BE IMPLEMENTED
        validMoves.push_back(to);
    }

    // TODO: Add logic here for castling as a possible move
    // TODO: Add logic here for capturing on passage as a possible move
    // These moves are "special" and are not generated by the standard Piece::getPossibleMoves.

    return validMoves;
}

bool Game::makeMove(Position from, Position to) {
    const Piece* pieceToMove = m_board.getPieceAt(from);

    if (pieceToMove == nullptr || pieceToMove->getColor() != m_currentPlayer) {
        std::cout << "ERROR: No piece or wrong color piece at " << from.row << "," << from.col << std::endl;
        return false;
    }

    std::vector<Position> allowedMoves = getValidMoves(from);
    bool isMoveValid = false;
    for (const Position& validPos : allowedMoves) {
        if (validPos == to) {
            isMoveValid = true;
            break;
        }
    }

    if (!isMoveValid) {
        std::cout << "ERROR: Invalid move from" << from.row << "," << from.col
            << " to " << to.row << "," << to.col << std::endl;
        return false;
    }

    m_lastMoveInfo = LastMoveInfo();
    m_lastMoveInfo.from = from;
    m_lastMoveInfo.to = to;
    m_lastMoveInfo.movedPieceType = pieceToMove->getType();
    m_lastMoveInfo.movedPieceColor = pieceToMove->getColor();

    if (pieceToMove->getType() == PieceType::Pawn && std::abs(to.row - from.row) == 2) {
        m_lastMoveInfo.isPawnDoubleStep = true;
        m_lastMoveInfo.enPassantTargetSquare = { from.row + (to.row - from.row) / 2, to.col };
    }

    // TODO: Processing special moves (Castle, En Passant)
    // if (handleCastling(from, to)) { /* ... */ }
    // else if (handleEnPassant(from, to)) { /* ... */ }
    // else
    m_board.movePiece(from, to);

    if(pieceToMove->getType() == PieceType::King) {
        if (pieceToMove->isWhite()) m_whiteKingMoved = true;
        else m_blackKingMoved = true;
    }
    else if(pieceToMove->getType() == PieceType::Rook) {
        if (pieceToMove->isWhite()) {
            if (from.col == 0) m_whiteRookMoved[0] = true;
            else if (from.col == 7) m_whiteRookMoved[1] = true;
        }
        else {
            if (from.col == 0) m_blackRookMoved[0] = true;
            else if (from.col == 7) m_blackRookMoved[1] = true;
        }
    }

    if (handlePawnPromotion(to)) {
        // The pawn has been transformed, further logic for the transformation occurs inside
    }

    switchPlayer();

    // TODO: Checkmate, stalemate after every move
    // if (isKingInCheck(m_currentPlayer)) {
    //     if (isCheckmate(m_currentPlayer)) { // You will need to implement isCheckmate
    //         std::cout << "Checkmate! " << (m_currentPlayer == Color::White ? "Black" : "White") << " wins!" << std::endl;
    //     }
    //     else {
    //         std::cout << "Check!" << std::endl;
    //     }
    // }
    // else if (isStalemate()) { // You will need to implement isStalemate
    //     std::cout << "Stalemate! Draw." << std::endl;
    // }
    std::cout << "Move made: " << from.row << "," << from.col
        << " to " << (int)to.row << "," << (int)to.col << std::endl;
    return true;
}

bool Game::isKingInCheck(Color kingColor) const {
    // To implement this correctly:
    // 1. Find king position for this color.
    // 2. For each piece opposite color:
    //    a. Get it pseudo-legal moves (getPossibleMoves)
    //    b. Check whether there is a king position among these moves
    // It's difficult function, better implement it after basic game logic
    // For now we're returning false
    return false;
}

bool Game::isGameOver() const {
    // For now we're returning false
    // Here will be the logic for checking for checkmate and stalemate
    return false;
}

void Game::printGameState() const {
    std::cout << "\n--- Current Game State ---" << std::endl;
    m_board.printBoard();
    std::cout << "Current Player: " << (m_currentPlayer == Color::White ? "White" : "Black") << std::endl;
    std::cout << "Last Move: "
        << m_lastMoveInfo.from.row << "," << m_lastMoveInfo.from.col
        << " to " << m_lastMoveInfo.to.row << "," << m_lastMoveInfo.to.col
        << (m_lastMoveInfo.isPawnDoubleStep ? " (Pawn Double Step)" : "") << std::endl;
    if (m_lastMoveInfo.isPawnDoubleStep) {
        std::cout << "En Passant Target: " << m_lastMoveInfo.enPassantTargetSquare.row << "," << m_lastMoveInfo.enPassantTargetSquare.col << std::endl;
    }

    std::cout << "--------------------------\n" << std::endl;
}

void Game::switchPlayer() {
    m_currentPlayer = (m_currentPlayer == Color::White) ? Color::Black : Color::White;
}

// TODO: Implement willMovePutKingInCheck properly (requires simulating moves)
bool Game::willMovePutKingInCheck(Position from, Position to) const {
    // To fully implement this method:
    // 1. Create a copy of the current board (Board tempBoard = m_board;).
    // 2. Make a "simplified" move on this temporary board (tempBoard.movePiece(from, to);).
    // 3. Check if the current player's king (after the move) is in check on the tempBoard.
    // (return tempBoard.isKingInCheck(m_currentPlayer); - requires an isKingInCheck method on Board or a separate RulesValidator class)
    // For now, return false to allow all moves.
    return false; // TEMPORARY!
}

// TODO: Implement getAttackedSquares (very similar to isKingInCheck, but returns a vector)
std::vector<Position> Game::getAttackedSquares(Color attackerColor) const {
    // Empty TEMPORARY!
    return {};
}

// TODO: Implement handleCastling
bool Game::handleCastling(Position from, Position to) {

    return false;
}

bool Game::handleEnPassant(Position from, Position to) {
    return false;
}

bool Game::handlePawnPromotion(Position pawnPos) {
    const Piece* piece = m_board.getPieceAt(pawnPos);
    if (piece == nullptr || piece->getType() != PieceType::Pawn) {
        return false;
    }

    bool isPromotion = false;
    if (piece->isWhite() && pawnPos.row == 7) {
        isPromotion = true;
    }
    else if (!piece->isWhite() && pawnPos.row == 0) {
        isPromotion = true;
    }

    if (isPromotion) {
        PieceType promotionChoice = PieceType::Queen;

        m_board.setPieceAt(pawnPos, PieceFactory::createPiece(promotionChoice, piece->getColor()));
        std::cout << "Pawn at (" << pawnPos.row << "," << pawnPos.col << ") promoted to Queen!" << std::endl;
        return true;
    }
    return false;
}
